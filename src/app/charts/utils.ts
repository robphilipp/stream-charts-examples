import {Dimensions, Margin} from "./styling/margins"
import * as d3 from "d3";
import {Selection} from "d3";

/**
 * No operation function for use when a default function is needed
 */
export const noop = () => {
    /* empty on purpose */
}

/**
 * Calculates whether the mouse is in the plot-area
 * @param x The x-coordinate of the mouse's position
 * @param y The y-coordinate of the mouse's position
 * @param margin The plot margins
 * @param dimensions The the overall dimensions (plot dimensions plus margin)
 * @return `true` if the mouse is in the plot area; `false` if the mouse is not in the plot area
 */
export function mouseInPlotAreaFor(x: number, y: number, margin: Margin, dimensions: Dimensions): boolean {
    return x > margin.left &&
        x < dimensions.width - margin.right &&
        y > margin.top &&
        y < dimensions.height - margin.bottom
}

/**
 * Calculates the width of an SVG text element, based on its bounding box
 * @param elem The SVG text element
 * @return The width in pixels, or 0 if SVG text element has not children
 */
export function textWidthOf(elem: Selection<SVGTextElement, any, any, any>): number {
    return elem.node()?.getBBox()?.width || 0
}

/**
 * Type for representing the dimensions and location of the bounding box for an
 * SVG text element.
 */
export type BoundingBox = { x: number, y: number, width: number, height: number }

/**
 * @return An empty bounding box with x, y, width, height set to 0.
 */
export function emptyBoundingBox(): BoundingBox {
    return {x: 0, y: 0, width: 0, height: 0}
}

/**
 * Calculates the width and height of the text element
 * @param elem The SVG text element
 * @return The width and height of the bounding box
 */
export function textDimensions(elem: Selection<SVGTextElement, any, any, any>): BoundingBox {
    const boundingBox = elem.node()?.getBBox()
    return {
        width: boundingBox?.width || 0,
        height: boundingBox?.height || 0,
        x: boundingBox?.x || 0,
        y: boundingBox?.y || 0
    }
}

export function formatNumber(value: number, format: string): string {
    return isNaN(value) ? '---' : d3.format(format)(value)
}

export function formatTime(value: number, units: string = ""): string {
    return `${formatNumber(value, " ,.0f")}${!isNaN(value) && units ? ` ${units}` : ""}`
}

export function formatValue(value: number): string {
    return formatNumber(value, " ,.3f")
}

export function formatChange(v1: number, v2: number, format: string): string {
    return isNaN(v1) || isNaN(v2) ? '---' : d3.format(format)(v2 - v1)
}

export function formatTimeChange(v1: number, v2: number): string {
    return formatChange(v1, v2, " ,.0f")
}

export function formatValueChange(v1: number, v2: number): string {
    return formatChange(v1, v2, " ,.3f")
}

/**
 * Calculates the (min, max) of all the values (from the accessor) in the data matrix, clamped by the global
 * (currentMin, currentMax).
 *
 * Curried function that accepts an accessor used to grab the value from the data point, and array of (x, y) values
 * (each (x, y) value is represented as [number, number] tuple), and a global, current min and max values. The
 * global, current min and max clamp the calculated min and max values.
 * @param accessor Access function that accepts a datum and returns the value which to use in the min-max calc
 * @return A function that accepts data (represented as a matrix of (x, y) pairs, where each row is a data series),
 * a global currentMin and currentMax, which clamp the calculated results. The function return a tuple holding the
 * min as the first value and the max as the second value.
 * @example
 * // function that calculates the min-max of the y-values generated by calling the minMaxOf and handing it the
 * // accessor function that grabs the y-value from the datum
 * const minMaxTimeSeriesY: (data: Array<TimeSeries>, currentMinMax: [number, number]) => [number, number] =
 minMaxOf((datum: [number, number]): number => datum[1])
 */
export const minMaxOf = <T>(accessor: (v: T) => number) =>
    (data: Array<Array<T>>, currentMinMax: [number, number]): [number, number] => [
        Math.min(d3.min(data, series => d3.min(series, datum => accessor(datum))) || 0, currentMinMax[0]),
        Math.max(d3.max(data, series => d3.max(series, datum => accessor(datum))) || 1, currentMinMax[1])
    ]
